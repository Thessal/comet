// example.cm
// Defines combinations of binary, ternary, and unary logics

import "stdlib.cm"
import "data/universe.cm"

// 1. Unary Logic (Normalization)
// Search Space: ZScore vs Rank vs Identity

// We define strategies as functions
zscore_norm(x: Series) -> Series
zscore_norm(x) = zscore(x)

rank_norm(x: Series) -> Series
rank_norm(x) = rank(x)

keep_norm(x: Series) -> Series
keep_norm(x) = x

// 2. Binary Logic (Comparison)

ratio_cmp(a: Series, b: Series) -> Series
ratio_cmp(a, b) = a / b

spread_cmp(a: Series, b: Series) -> Series
spread_cmp(a, b) = a - b

// 3. Ternary Logic (Condition/Trigger)

band_trigger(x: Series, high: Float, low: Float) -> Series
band_trigger(x, high, low) = trim_ternary(x, high, low)

// Main Flow
examples(price: Series, vol: Series) -> Series
examples(price, vol) =
    let
        // 1. Unary combinations (3 variants)
        norm_price = zscore_norm(price)

        // 2. Binary combinations
        // Price vs Price (Same Unit) -> Spread valid, Ratio valid.
        // Generates [Spread(price, norm_price), Ratio(price, norm_price)]
        diff = ratio_cmp(price, norm_price)

        // 3. Ternary combinations
        sig = band_trigger(diff, 2.0, -2.0)
    in
        sig
