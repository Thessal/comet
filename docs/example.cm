// example.cm
// Defines combinations of binary, ternary, and unary logics

import "stdlib.cm"
import "data/universe.cm"

// 1. Unary Logic (Normalization)
behavior Normalizer(x: Series) -> Series

fn zscore(x: Series) -> Series { return zscore_impl(x) } // Implementation of Normalizer
fn rank(x: Series) -> Series { return rank_impl(x) }     // Implementation of Normalizer
fn keep(x: Series) -> Series { return x }                // Implementation of Normalizer

// 2. Binary Logic (Comparison)
behavior Comparator(a: Series, b: Series) -> Series

fn ratio(a: Series, b: Series NonZero) -> Series { 
    return a / b
}

fn spread(a: Series, b: Series) -> Series { 
    return a - b
}

// 3. Ternary Logic (Condition/Trigger)
behavior SignalGen(x: Series, high: Const, low: Const) -> Series

fn band_trigger(x: Series, high: Const, low: Const) -> Series {
     return trim_ternary(x, high, low)
}

// 4. Input Definitions (Data Behaviors)
behavior PriceData() -> DataFrame Monetary ("price")
behavior VolumeData() -> DataFrame NonZero Count ("volume")

// 5. Flow
flow strategy_example = {
    // Inputs (synthesized via behavior call)
    p = PriceData()
    v = VolumeData()

    // 1. Unary combinations
    norm_price = Normalizer(p)
 
    // 2. Binary combinations
    // Comparator will synthesize Ratio(p, v) and Spread(p, v) if types match
    diff = Comparator(p, v)

    // 3. Ternary combinations
    sig = SignalGen(diff, 2.0, -2.0)
    
    return sig
}
