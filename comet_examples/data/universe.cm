import "../stdlib.cm"
// Data Universe Definitions

Type Instrument : Any derives {}

Type Price : Instrument derives { Monetary, NonZero }
Type Volume : Instrument derives { NonZero }
Type Earnings : Instrument derives { Monetary }

// Helper for Universe returns?
// Ideally Universe is generic: Universe(T) -> Structure
// In stdlib.cm we defined DataFrame, Series.
// We can define multiple Universe functions or overloading?
// Comet semantics supports overloading Behavior/Impl/Func?
// `Func` in grammar doesn't allow explicit overloading easily in single scope without polymorphism resolution.
// But we can define `fn Universe_Series(t) ...` or rely on return type inference?
// For now, let's just make Universe return `DataFrame` by default for broad financial data, or `Series`.
// Docs said `Universe(type) -> Series`.
// Let's change it to `DataFrame` if we want dense data.

fn Universe(t: Type) -> DataFrame {
   // Built-in magic placeholder
   // Returning DataFrame assumes aligned Universe data.
   return t
}

fn Universe_Series(t: Type) -> TimeSeries {
    return t
}
