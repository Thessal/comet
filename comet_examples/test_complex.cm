// test_complex.cm
// Complex strategy: Daily financial ratio data triggered by minutely volume spike.
// Condition: normalized(compare(volume, historical(volume))) > 0.8

import "stdlib.cm"
import "data/data.cm"

// Define missing Behaviors
Behavior Comparator(a, b) -> DataFrame
Behavior Historical(x) -> TimeSeries

// 1. Historical Implementation
Implementation NonzeroMovingAverage implements Historical(x) where x is NonZero ensures { NonZero } {
    return x 
}

// 2. Comparator Implementation
Implementation Ratio implements Comparator(a, b) where b is NonZero {
    return divide(a, b) 
}
Implementation RankDiff implements Comparator(a, b) ensures { Ranged } {
    return subtract(rank(a), rank(b))
}

// 3. Normalizer Implementation
Behavior UnboundNormalizer(T) -> T
Implementation ZScore implements UnboundNormalizer(x) {
    return zscore(x) 
}

// Normalizer in stdlib: Behavior Normalizer(T) -> T
Implementation UnBoundNormalizer implements Normalizer(x) {
    return UnboundNormalizer(x) // Does not ensure Ranged
}
Implementation Clipped implements Normalizer(x) ensures { Ranged } {
    return clip(UnboundNormalizer(x), 0,1) // Added to check nested Behavior
}
Implementation Rank implements Normalizer(x) ensures { Ranged } {
    return rank(x)
}
Implementation Clip implements Normalizer(x) ensures { Ranged } {
    return clip(x, 0, 1)
}
Implementation ZScore implements Normalizer(x) ensures {} {
    return zscore(x) //Tests duplicate impl name, and nonhomogeneous ensures
}


Flow Strategy {
    // Load Data
    daily_pe <- PE_Universe
    min_vol  <- Volume_Universe // Returns TimeSeries

    // Calculate Historical Volume
    hist_vol <- Historical(min_vol)

    // Compare Current vs Historical
    // Comparator needs to handle TimeSeries inputs now if we want that
    // Or we assume automatic promotion/alignment?
    // Let's assume Comparator works on compatible types.
    vol_ratio <- Comparator(min_vol, hist_vol)

    // Normalize the ratio (Spike Score)
    spike_score <- Normalizer(vol_ratio)

    // Output: updated when condition met
    // NEW LOGIC: apply_filter creating a mask
    masked_spike <- apply_filter(spike_score, 0.8)
    
    result = update_when(daily_pe, masked_spike)
    
    return result
}
