use crate::comet::ir::{ExecutionGraph, ExecutionNode, OperatorOp};
use std::collections::HashMap;

pub struct Codegen;

impl Codegen {
    pub fn new() -> Self {
        Codegen
    }

    pub fn generate_library(&self, contexts: &Vec<crate::comet::synthesis::Context>) -> String {
        let mut code = String::new();
        
        // Header
        code.push_str("// Generated by Comet\n");
        code.push_str("use polars::prelude::*;\n");
        code.push_str("use std::collections::HashMap;\n");
        code.push_str("use crate::comet::runtime::*;\n\n");
        
        // Struct Definitions
        code.push_str("#[derive(Debug, Clone)]\n");
        code.push_str("pub struct StrategyMeta {\n");
        code.push_str("    pub variant_id: u32,\n");
        code.push_str("    pub tags: HashMap<String, String>,\n");
        code.push_str("}\n\n");

        code.push_str("#[derive(Debug, Clone)]\n");
        code.push_str("pub struct DataSpec {\n");
        code.push_str("    pub universe: Vec<String>,\n");
        code.push_str("}\n\n");

        // get_meta
        code.push_str("pub fn get_meta(variant_id: u32) -> StrategyMeta {\n");
        code.push_str("    let mut tags = HashMap::new();\n");
        code.push_str("    tags.insert(\"version\".to_string(), \"0.1\".to_string());\n");
        code.push_str("    StrategyMeta { variant_id, tags }\n");
        code.push_str("}\n\n");

        // select
        code.push_str("pub fn select(variant_id: u32) -> DataSpec {\n");
        code.push_str("    match variant_id {\n");
        for (i, ctx) in contexts.iter().enumerate() {
            let universe = self.extract_universe(&ctx.graph);
            let uni_str = universe.iter().map(|s| format!("\"{}\".to_string()", s)).collect::<Vec<String>>().join(", ");
            code.push_str(&format!("        {} => DataSpec {{ universe: vec![{}] }},\n", i, uni_str));
        }
        code.push_str("        _ => DataSpec { universe: vec![] },\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");

        // generate_all
        code.push_str("pub fn generate_all(variant_id: u32, inputs: &Inputs) -> (DataFrame, State) {\n");
        code.push_str("    match variant_id {\n");
        for (i, _) in contexts.iter().enumerate() {
            code.push_str(&format!("        {} => (execute_variant_{}(inputs), State::default()),\n", i, i));
        }
        code.push_str("        _ => (DataFrame::default(), State::default()),\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");
        
        // generate (stub for now)
        code.push_str("pub fn generate(variant_id: u32, new_data: &Inputs, state: State) -> (DataFrame, State) {\n");
        code.push_str("    // Incremental not yet implemented, fallback to full calc stub or error\n");
        code.push_str("    generate_all(variant_id, new_data)\n");
        code.push_str("}\n\n");

        // Variant Executors
        for (i, ctx) in contexts.iter().enumerate() {
            code.push_str(&self.generate_variant_executor(i, &ctx.graph));
        }

        code
    }

    fn extract_universe(&self, graph: &ExecutionGraph) -> Vec<String> {
        let mut universe = Vec::new();
        for node in &graph.nodes {
            if let ExecutionNode::Source { name, .. } = node {
                universe.push(name.clone());
            }
        }
        universe
    }

    fn generate_variant_executor(&self, id: usize, graph: &ExecutionGraph) -> String {
        let mut code = String::new();
        code.push_str(&format!("fn execute_variant_{}(inputs: &Inputs) -> DataFrame {{\n", id));
        
        for (node_id, node) in graph.nodes.iter().enumerate() {
            match node {
                ExecutionNode::Source { name, type_name } => {
                    code.push_str(&format!("    let var_{} = inputs.get(\"{}\"); // {}\n", node_id, name, type_name));
                },
                ExecutionNode::Constant { value, type_name } => {
                    code.push_str(&format!("    let var_{} = {}; // {}\n", node_id, value, type_name));
                },
                ExecutionNode::Operation { op, args } => {
                     let arg_vars: Vec<String> = args.iter().map(|a| format!("&var_{}", a)).collect();
                     let call = match op {
                        OperatorOp::Divide => format!("comet::functions::divide({})", arg_vars.join(", ")),
                        OperatorOp::ZScore => format!("comet::functions::zscore({})", arg_vars.join(", ")),
                        OperatorOp::Filter => format!("comet::functions::filter({})", arg_vars.join(", ")),
                        OperatorOp::UpdateWhen => format!("comet::functions::update_when({})", arg_vars.join(", ")),
                         _ => format!("todo!(\"{:?}\")", op),
                     };
                     code.push_str(&format!("    let var_{} = {};\n", node_id, call));
                }
            }
        }
        
       if !graph.nodes.is_empty() {
             code.push_str(&format!("    var_{}\n", graph.nodes.len() - 1));
        } else {
            code.push_str("    DataFrame::default()\n");
        }
        
        code.push_str("}\n\n");
        code
    }
}
