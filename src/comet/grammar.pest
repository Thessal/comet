WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ ("//" ~ (!"\n" ~ ANY)*) | ("/*" ~ (!"*/" ~ ANY)* ~ "*/") }

program = { SOI ~ module_decl ~ import_decl* ~ declaration* ~ EOI }

module_decl = { "module" ~ identifier }
import_decl = { "import" ~ path_ident }

declaration = {
    adt_decl |
    synonym_decl |
    class_decl |
    instance_decl |
    func_decl
}

// Identifiers
keyword = { "module" | "import" | "class" | "instance" | "where" | "let" | "in" | "case" | "of" | "true" | "false" }
identifier = @{ !keyword ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
path_ident = @{ identifier ~ ("." ~ identifier)* } // Data.Universe

// Types
type_ref = { function_type }
function_type = { app_type ~ ("->" ~ app_type)* } // a -> b -> c
app_type = { atom_type+ } // List a (List applied to a)
atom_type = {
    type_var |
    concrete_type |
    "(" ~ type_ref ~ ")"
}
concrete_type = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }
type_var = @{ !assignment_check ~ !keyword ~ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* }
ws = _{ " " | "\t" | "\n" | "\r" }
assignment_check = @{ identifier ~ ws* ~ ("=" | "::") }

// ADTs: :: List a = Cons a (List a) | Nil
adt_decl = { "::" ~ concrete_type ~ type_var* ~ "=" ~ constructors }
constructors = { constructor ~ ("|" ~ constructor)* }
constructor = { concrete_type ~ atom_type* }

// Synonyms: :: Volume :== Series Real
synonym_decl = { "::" ~ concrete_type ~ type_var* ~ ":==" ~ type_ref }

// Classes: class Comparator a b c :: a b -> c
class_decl = { 
    "class" ~ concrete_type ~ type_var* ~ "::" ~ type_ref |
    "class" ~ concrete_type ~ type_var*
}

// Instances: instance Comparator Volume Volume Series | NonZero b where ...
instance_decl = { 
    "instance" ~ concrete_type ~ atom_type* ~ ("|" ~ constraints)? ~ 
    ("where" ~ func_def+)? 
}
constraints = { constraint ~ ("&" ~ constraint)* }
constraint = { concrete_type ~ type_var* } // NonZero a

// Functions
// Signature: name :: Type -> Type OR name(arg: Type, ...) -> Type
// Definition: name args = expr OR name(args) = expr
func_decl = { func_sig? ~ func_def }

func_sig = { 
    (identifier ~ "::" ~ type_ref ~ ("|" ~ constraints)?) |
    (identifier ~ "(" ~ typed_args? ~ ")" ~ "->" ~ type_ref ~ ("|" ~ constraints)?)
}

typed_args = { typed_arg ~ ("," ~ typed_arg)* }
typed_arg = { identifier ~ ":" ~ type_ref }

func_def = { 
    (identifier ~ identifier* ~ "=" ~ expr ~ ("where" ~ func_def+)? ) |
    (identifier ~ "(" ~ param_list? ~ ")" ~ "=" ~ expr ~ ("where" ~ func_def+)? )
}
param_list = { identifier ~ ("," ~ identifier)* }

// Expressions
expr = { let_expr | case_expr | logic_expr }

let_expr = { "let" ~ func_def+ ~ "in" ~ expr }
case_expr = { "case" ~ expr ~ "of" ~ case_arm+ }
case_arm = { pattern ~ "=" ~ expr }

pattern = {
    adt_pattern |
    var_pattern |
    wildcard_pattern
}
adt_pattern = { concrete_type ~ identifier* } // Still curried for ADT match for now
var_pattern = { identifier }
wildcard_pattern = { "_" }

logic_expr = { term ~ (op_logic ~ term)* }
term = { factor ~ (op_compare ~ factor)* }
factor = { atom ~ (op_arith ~ atom)* }

atom = {
    literal |
    call_expr |
    app_expr |
    identifier |
    "(" ~ expr ~ ")"
}

// f(x, y)
call_expr = { identifier ~ "(" ~ expr_list? ~ ")" }
expr_list = { expr ~ ("," ~ expr)* }

// Legacy curried: f x y
app_expr = { identifier ~ app_arg+ }
app_arg = { !assignment_check ~ atom }

// Operators
op_logic = { "&&" | "||" }
op_compare = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
op_arith = { "+" | "-" | "*" | "/" }

literal = { float_literal | int_literal | string_literal | bool_literal }
int_literal = @{ ASCII_DIGIT+ }
float_literal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
bool_literal = { "true" | "false" }
