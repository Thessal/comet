WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ ("//" ~ (!"\n" ~ ANY)*) | ("/*" ~ (!"*/" ~ ANY)* ~ "*/") }

program = { SOI ~ declaration* ~ EOI }

declaration = {
    import_decl |
    type_decl |
    behavior_decl |
    flow_decl |
    func_decl
}

identifier = @{ !keyword ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "'")* }

keyword = _{ 
    k_type | k_behavior | k_flow | k_fn | k_return | k_import 
}
int_literal = @{ ASCII_DIGIT+ }
float_literal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
bool_literal = { "true" | "false" }
literal = { float_literal | int_literal | string_literal | bool_literal }

// Keywords
// Keywords
k_type = { "type" }
k_behavior = { "behavior" }
k_flow = { "flow" }
k_fn = { "fn" }
k_return = { "return" }
k_import = { "import" }

import_decl = { k_import ~ string_literal }

// type A : B C
type_decl = { k_type ~ identifier ~ (":" ~ constraint)? ~ ("{" ~ property_list? ~ "}")? ~ ( "[" ~ component_list ~ "]" )? }
property_list = { identifier ~ ("," ~ identifier)* }
component_list = { identifier ~ ("," ~ identifier)* }

type_ref = { identifier }

// center : Point
// Not using struct/enum anymore.

comma = _{ "," }

// behavior Compare (A, B) -> Series
behavior_decl = { k_behavior ~ identifier ~ "(" ~ typed_arg_list ~ ")" ~ "->" ~ constraint }
arg_list = { (identifier ~ (comma ~ identifier)*)? }
typed_arg_list = { (typed_arg ~ (comma ~ typed_arg)*)? }
typed_arg = { identifier ~ ":" ~ constraint }

// func
func_decl = { k_fn ~ identifier ~ "(" ~ typed_arg_list? ~ ")" ~ "->" ~ constraint ~ block }

block = { "{" ~ statement* ~ "}" }

flow_decl = { k_flow ~ identifier ~ "=" ~ expr }

statement = {
    assignment_stmt |
    return_stmt |
    expr_stmt
}

assignment_stmt = { identifier ~ "=" ~ expr }
return_stmt = { k_return ~ expr }
expr_stmt = { expr }

// Constraints
// A B | C -> (A + B) | C
constraint = { union_constraint }
union_constraint = { add_constraint ~ ("|" ~ add_constraint)* }
add_constraint = { sub_constraint ~ (sub_constraint)* }
sub_constraint = { atom_constraint ~ ("-" ~ atom_constraint)? }
atom_constraint = { ("(" ~ constraint ~ ")") | identifier | string_literal }

// Expressions
expr = { or_expr }
or_expr = { and_expr ~ (op_or ~ and_expr)* }
and_expr = { eq_expr ~ (op_and ~ eq_expr)* }
eq_expr = { rel_expr ~ (op_eq ~ rel_expr)* }
rel_expr = { add_expr ~ (op_rel ~ add_expr)* }
add_expr = { mul_expr ~ (op_add ~ mul_expr)* }
mul_expr = { unary_expr ~ (op_mul ~ unary_expr)* }
unary_expr = { op_unary? ~ atom }

op_or = { "||" }
op_and = { "&&" }
op_eq = { "==" | "!=" }
op_rel = { "<=" | ">=" | "<" | ">" }
op_add = { "+" | "-" }
op_mul = { "*" | "/" }
op_unary = { "-" | "!" }

atom = { primary ~ postfix* }
postfix = { call_suffix | member_suffix }
call_suffix = { "(" ~ arg_values ~ ")" }
member_suffix = { "." ~ identifier }

primary = {
    literal |
    path |
    paren_expr |
    list_literal
}

path = ${ identifier ~ ("::" ~ identifier)* }
paren_expr = { "(" ~ expr ~ ")" }
list_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
arg_values = { (arg_value ~ ("," ~ arg_value)*)? }
arg_value = { (identifier ~ "=")? ~ expr }
